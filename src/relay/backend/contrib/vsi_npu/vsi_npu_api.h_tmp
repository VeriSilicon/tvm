#ifndef TVM_RELAY_BACKEND_CONTRIB_VSI_NPU_VSI_NPU_API_H_
#define TVM_RELAY_BACKEND_CONTRIB_VSI_NPU_VSI_NPU_API_H_

#include <tvm/relay/expr.h>
#include <tvm/relay/expr_functor.h>
#include <tvm/relay/transform.h>
#include <tvm/tir/analysis.h>
#include <tvm/tir/op.h>

#include <algorithm>
#include <limits>
#include <map>
#include <memory>
#include <string>
#include <utility>
#include <vector>

#include <tim/vx/ops/elementwise.h>
#include <tim/vx/tensor.h>
#include <tim/vx/types.h>

namespace tvx = tim::vx;

namespace tvm {
namespace relay {
namespace contrib {
namespace vsi_npu {

using TensorInfoTable = std::map<Expr, std::vector<::tim::vx::TensorSpec>>;
using VxTensorTable = std::map<Expr, std::vector<std::shared_ptr<::tim::vx::Tensor>>>;
using VxOperationTable = std::map<Expr, std::shared_ptr<::tim::vx::Operation>>;

namespace {
// Get a T from a constant represented by a NDArray.
template <typename T>
bool AsConstant(const Expr& expr, T* out) {
  if (!expr->IsInstance<ConstantNode>()) {
    return false;
  }
  runtime::NDArray data = Downcast<Constant>(expr)->data;
  *out = *static_cast<T*>(data->data);
  return true;
}
// bool IsVsiNpuOp(const Call& call, const std::string& op_name) {
//   if (call->op->IsInstance<OpNode>()) {
//     Op op = Downcast<Op>(call->op);
//     CHECK(op.defined());
//     return op == Op::Get(op_name);
//   } else {
//     return false;
//   }
// }
}  // namespace

class VsiError {
  // TODO
};

class VsiNpuAPI {
 public:
  static VsiError Addition(const Expr& expr, TensorInfoTable& ti_tb, tim::vx::Quantization& quant_info);
  static VsiError Addition(const Expr& expr, TensorInfoTable& ti_tb);
  static VsiError Relu(const Expr& expr, TensorInfoTable& ti_tb,tim::vx::Quantization& quant_info);
  static VsiError Softmax(const Expr& expr, TensorInfoTable& ti_tb,tim::vx::Quantization& quant_info);
  //static bool IsVsiNpuOp(const Call& call);
};

}  // namespace vsi_npu
}  // namespace contrib
}  // namespace relay
}  // namespace tvm

#endif